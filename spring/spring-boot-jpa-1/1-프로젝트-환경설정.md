## 일반적인 웹 애플리케이션 개발 과정

- 요구사항 분석
- 도메인과 테이블 설계
- 아키텍처 구성
- 핵심 비즈니스 로직 개발
- 웹 계층 개발
- 테스트
- 성능 최적화

## 1. 프로젝트 환경설정

### 테스트 라이브러리

- spring-boot-starter-test
    - **junit**: 테스트 프레임워크
    - mockito: 목 라이브러리
    - assertj: 테스트 코드를 좀 더 편하게 작성하게 도와주는 라이브러리 
    - **spring-test**: 스프링 **통합 테스트** 지원
- 핵심 라이브러리 
    - 스프링 MVC 
    - 스프링 ORM
    - **JPA**, 하이버네이트
    - **스프링 데이터 JPA**
- 기타 라이브러리
    - **H2** 데이터베이스 클라이언트 
    - 커넥션 풀: 부트 기본은 HikariCP
    - WEB(thymeleaf)
    - 로깅 **SLF4J** & LogBack 
    - 테스트

- **서버 재시작 없이 View 파일 변경**하는 법
    - `build.gradle` - `dependencies`에 다음 줄 추가
        - `implementation 'org.springframework.boot:spring-boot-devtools'`
    - 적용 이후에는 `build -> recompile` 로 파일마다 변경할 수 있음

### application 설정

- `.properties` 대신, **설정이 많아졌을 때 유리**한 `.yml`로 변경함
    - `application.properties` -> `application.yml`
    - `.yml`은 들여쓰기로 계층을 구분함
        ```yml
        # DB Setting
        spring:
          datasource:
            driver-class-name: oracle.jdbc.driver.OracleDriver
            url: jdbc:oracle:thin:@localhost:1521:orcl
            username: username
            password: password
        ```
    - `.properties`는 각 줄마다 절대경로를 붙임
        ```properties
        # DB Setting
        spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
        spring.datasource.url=jdbc:oracle:thin:@localhost:1521:orcl
        spring.datasource.username=username
        spring.datasource.password=password
        ```

> preference - Live Templates 에서 내 마음대로 예약어를 만들 수 있음
   

- 테스트 메서드에 붙인 `@Transactional`은 테스트 종료 시점에 rollback 해버림
    - 이를 `@Rollback(false)`까지 덧붙이면 데이터를 유지할 수 있음

- 쿼리 파라미터에 로그를 남길 수 있음
    - 알면 개발할 때 엄청 편해짐
    - jpa를 쓸 때 답답한 점이, sql 나가는 거랑 데이터베이스 커넥션 가져오는 과정이 어느 타이밍에 일어나는 지 궁금함.
    - 이때 쿼리 파라미터를 직접 찍는 건 답답한 점이 있음 (물음표가 찍힘)
        ```.yml
        logging:
          level:
            org.hibernate.type: trace
        ```
    - 이때, 외부 라이브러리를 사용하면 편함
        - `github.com/gavlyukovskiy/spring-boot-data-source-decorator`
    - 스프링 부트를 사용하면 이 라이브러리를 추가하면 됨 (스프링 부트 3.0 기준)
        - `implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0'`
> 참고: 쿼리 파라미터를 로그로 남기는 외부 라이브러리는 시스템 자원을 사용하므로, 개발 단계에서는 편하 게 사용해도 된다. 하지만 운영시스템에 적용하려면 꼭 성능테스트를 하고 사용하는 것이 좋다.

### 도메인 분석 설계

- 요구사항은 다음과 같음
    - ![Alt text](image.png)
    - 회원 기능 
        - 회원 등록
        - 회원 조회 
    - 상품 기능
        - 상품 등록
        - 상품 수정
        - 상품 조회
    - 주문 기능 
        - 상품 주문
        - 주문 내역 조회
        - 주문 취소
    - 기타 요구사항
        1. 상품은 재고 관리가 필요하다.
        2. 상품의 종류는 도서, 음반, 영화가 있다. 
        3. 상품을 카테고리로 구분할 수 있다.
        4. 상품 주문시 배송 정보를 입력할 수 있다.
- 회원 도메인 모델은 다음과 같음
    - ![Alt text](image-1.png)
- 회원 엔티티는 다음과 같이 분석할 수 있음
    - ![Alt text](image-2.png)
        - JPA로 표현할 수 있는 모든 관계를 담은 내용임
        - 이때 1:1은 일대일, 1:* 일대다, \*:\* 는 다대다
            - 다대다는 실무에서 쓰면 안 됨, 기본편 참고
        - 양방향 관계 또한 권장하지 않음
    - 회원(Member)
        - 이름과 임베디드 타입인 주소(Address), 그리고 주문(`orders`) 리스트를 가짐
    - 주문(Order)
- 회원 테이블은 다음과 같이 분석할 수 있음
    - ![Alt text](image-3.png)
    - `CATEGORY`와 `ITEM`은 다대다 관계이므로 `CATEGORY_ITEM`을 중간에 끼어둠
        - 다대다 관계는 일대다 -> 매핑 테이블 -> 다대일로 풀어서 설계함
- 연관관계 매핑 분석
    - **회원과 주문**
        - 일대다, 다대일의 양방향 관계
        - 따라서 연관관계의 주인을 정해야 함
            - 외래 키가 있는 주문을 연관관계의 주인으로 정하는 것이 좋음
            > (기본편 내용) 외래키가 가까운 곳에 있는 거를 연관관계의 주인으로 정하는 것이 편함
        - 그러므로 `Order.member` 를 `ORDERS.MEMBER_ID` 외래 키와 매핑함
    - **주문상품과 주문**
        - 다대일 양방향 관계
    - **주문상품과 상품** 
        - 다대일 단방향 관계
    - **주문과 배송**
        - 일대일 양방향 관계
    - **카테고리와 상품**
        - `@ManyToMany`를 사용하여 매핑함
            - 실무에서는 `@ManyToMany`를 사용하지 말 것!!
>  참고: 외래 키가 있는 곳을 연관관계의 주인으로 정해라.

> 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제이지 비즈니스상 우위에 있다고 주인으로 정하면 안된다. 예를 들어서 자동차와 바퀴가 있으면, 일대다 관계에서 항상 다쪽에 외래 키가 있으므로 외래 키가 있는 바퀴를 연관관계의 주인으로 정하면 된다. 물론 자동차를 연관관계의 주인으로 정하는 것이 불가능 한 것은 아니지만, 자동차를 연관관계의 주인으로 정하면 자동차가 관리하지 않는 바퀴 테이블의 외래 키 값이 업데이트 되므로 관리와 유지보수가 어렵고, 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 있 다. 자세한 내용은 JPA 기본편을 참고하자.



---

## 다음 글

### 2. [도메인-분석-설계](2-도메인-분석-설계.md)

---